using System.Text.RegularExpressions;
using Lagrange.Core.Message;
using Lagrange.XocMat.Extensions;
using Newtonsoft.Json;

namespace Reply;

public enum ContentType { Text, Image, Face, Video, At, Forward, SelectAt }

public class ContentItem(ContentType type, string content)
{
    public ContentType Type { get; set; } = type;
    public string Content { get; set; } = content;
}

public class Response
{
    public List<ContentItem> Contents { get; set; } = new List<ContentItem>();
}

public class ReplyRule
{
    public string MatchPattern { get; set; }
    
    [JsonIgnore]
    public Regex TriggerRegex { get; set; }
    public string ReplyTemplate { get; set; }

    public ReplyRule(string matchPattern, string replyTemplate)
    {
        MatchPattern = matchPattern;
        ReplyTemplate = replyTemplate;
        TriggerRegex = new Regex(matchPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
    }
}

public delegate Task<string> AsyncVariableHandler(string varName, string? param, MessageChain chain);

public class ReplyAdapter
{
    private static List<ReplyRule> _rules => Config.Instance.Rules;
    private static readonly Dictionary<string, AsyncVariableHandler> _asyncHandlers = [];
    
    public static Action<string> Logger { get; set; } = Console.WriteLine;

    public static void RegisterAsyncHandler(string varName, AsyncVariableHandler handler)
    {
        _asyncHandlers[varName.ToLower()] = handler;
    }

    public static List<string> GetVariablles()
    {
        return [.. _asyncHandlers.Keys];
    }

    public static async Task<Response?> ProcessMessageAsync(MessageChain chain)
    {
        var message = chain.GetText().Trim();
        foreach (var rule in _rules)
        {
            Logger($"正在测试规则: {rule.MatchPattern}");
            
            var match = rule.TriggerRegex.Match(message);
            if (!match.Success) continue;

            Logger($"匹配成功，捕获组数: {match.Groups.Count}");
            for (int i = 0; i < match.Groups.Count; i++)
            {
                Logger($"Group[{i}]: {match.Groups[i].Value}");
            }

            var processed = await ProcessTemplateAsync(match, rule.ReplyTemplate, chain);
            return BuildResponse(processed);
        }
        return null;
    }

    private static async Task<string> ProcessTemplateAsync(Match match, string template, MessageChain chain)
    {
        var step1 = await ReplaceVariablesAsync(template, chain);
        return ReplaceRegexGroups(match, step1);
    }

    private static string ReplaceRegexGroups(Match match, string input)
    {
        return Regex.Replace(input, @"\$(\d+)", m =>
        {
            if (!int.TryParse(m.Groups[1].Value, out int index)) return m.Value;
            
            if (index <= 0 || index >= match.Groups.Count)
            {
                Logger($"无效分组索引: ${index}");
                return m.Value;
            }
            
            var value = match.Groups[index].Value;
            Logger($"替换占位符: ${index} → {value}");
            return value;
        });
    }

    private static async Task<string> ReplaceVariablesAsync(string input, MessageChain chain)
    {
        var pattern = @"\$(\w+)(?::([^$]+))?";
        var replacements = new Dictionary<string, string>();

        foreach (Match m in Regex.Matches(input, pattern))
        {
            var varName = m.Groups[1].Value.ToLower();
            var parameter = m.Groups[2].Success ? m.Groups[2].Value : null;
            
            if (_asyncHandlers.TryGetValue(varName, out var handler))
            {
                try
                {
                    var value = await handler(varName, parameter, chain);
                    replacements[m.Value] = value;
                }
                catch (Exception ex)
                {
                    Logger($"处理变量错误: {varName} - {ex.Message}");
                    replacements[m.Value] = $"[处理{varName}失败]";
                }
            }
        }

        return Regex.Replace(input, pattern, m => 
            replacements.GetValueOrDefault(m.Value, m.Value));
    }

    private static Response BuildResponse(string processed)
    {
        var response = new Response();
        var pattern = @"{(?<type>\w+):\s*(?<content>[^}]+?)\s*}|(?<text>[^{]*)";

        foreach (Match m in Regex.Matches(processed, pattern))
        {
            if (m.Groups["type"].Success)
            {
                var item = CreateContentItem(
                    m.Groups["type"].Value,
                    m.Groups["content"].Value.Trim()
                );
                if (item != null) response.Contents.Add(item);
            }
            else
            {
                AddTextContent(response, m.Groups["text"].Value.Trim());
            }
        }

        return response;
    }

    private static ContentItem CreateContentItem(string type, string content)
    {
        return type.ToLowerInvariant() switch
        {
            "face" when IsValidFaceId(content) => new ContentItem(ContentType.Face, content),
            "image" when IsValidUrl(content) => new ContentItem(ContentType.Image, content),
            "video" when IsValidUrl(content) => new ContentItem(ContentType.Video, content),
            "at" when IsValidUin(content) => new ContentItem(ContentType.At, content),
            "forward" when !string.IsNullOrEmpty(content) => new ContentItem(ContentType.Forward, content),
            "select" when !string.IsNullOrEmpty(content) => new ContentItem(ContentType.SelectAt, content),
            _ => new ContentItem(ContentType.Text, content)
        };
    }

    private static void AddTextContent(Response response, string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            response.Contents.Add(new ContentItem(ContentType.Text, text));
        }
    }

    private static bool IsValidFaceId(string input) => 
        int.TryParse(input, out _);

    private static bool IsValidUrl(string input) => 
        Uri.TryCreate(input, UriKind.Absolute, out _);

    private static bool IsValidUin(string input) =>
        uint.TryParse(input, out _);
}